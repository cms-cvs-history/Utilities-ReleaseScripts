#! /usr/bin/env python
#pylint: disable-msg=W0403
"""
BuildSet - utilizes dependency discovery mechanism for Partial Releases.
"""
__revision__ = "$Id: BuildSet,v 1.4 2007/06/05 19:55:47 ratnik Exp $"
__version__ = "$Revision: 1.4 $"

import os
import sys
import getopt
import string
import urllib
import re

programPath = os.path.dirname( os.path.realpath(sys.argv[0] ) ) 
programName = os.path.basename( sys.argv[0] )

global verbose
verbose               = 1
packageListInFile     = 0
dependencyAnalysisDir = "http://cern.ch/cms-sdt/ignominy"
afspath="/afs/cern.ch/cms/sdt/web/ignominy"
# Read from afs directory if available (much faster):
if os.path.exists (afspath):
    dependencyAnalysisDir = afspath

dependencies          = []
outputFormats         = ("packages", "tools", "dependencies")
outputFormat          = None

# Format specific patterns:
dependencyFormat      = "xdeps.all"
beginBlock = re.compile('# Merged dependencies\t*')
endBlock   = re.compile('.*#.*')
depEntry   = re.compile('(\d*/\d*)\s*(\S*)\s*(\S*)')
firstline  = "#"*25

##############################################################
# Internal utility functions:

def usage():
    """
    Prints out usage help
    """
    # Require minimum arguments and use options only to
    # override the defaults
    print """
USAGE:
    """ + programName + """ [OPTIONS] <release name>  [<package>]+
OPTIONS:
   -d dir     - get dependency information from directory dir,
                also supports urls.
                Default:   http://cern.ch/cms-sdt/ignominy 
   -f file    - read list of packages from file.
   -h         - print this help and exit.
   -v         - display version number.
   -q         - run quietly, suppressing info output.
   -o format  - format = [""" + "|".join(outputFormats) + """ ]
                print out formatted output (e.g. only packages, or
                only tools, one per line).
"""

def usageError ( message, programName) :
    """
    usageError:
      Call it to quit in case of usage error
    """
    if verbose:
        print "Usage error: ", message, \
              "\nTry \'" + programName + " -h\' for help"
    sys.exit ( 2 )

    
def infoOut(infoString):
    """
    Informative printout with verbosity control.
    """
    if verbose:
        print "##", programName, "info: ", infoString

##############################################################
# Interface functions:

def readPackageFromFile(line, list):
    """
      Reads package name in the line (from file object) and adds it
      to the packages list.
      Ignores comments started with hash (#).
      More checks (e.g. validate package names) could be added.
    """
    # Discard comments
    line = re.sub('\t*#.*', '', line)
    blankLine = re.compile('(\t*\n)')
    # Skip blank lines
    result = blankLine.match(line)
    if result:
        return 0
    else:
        list.append(line.strip())

def readDependencies(line, list):
    """
    Parses the line from the file that provides dependency info, and
    updates dependency list accordingly.
    Uses format of xdeps.all file produced by Ignominy.
    """
    result = depEntry.match(line)
    if result:
        (statistics, package, requires) = depEntry.match(line).groups()
        list.append(package+":"+requires)

# Handle options and arguments:
try:
    opts, args = getopt.getopt( sys.argv[1:], "hnqvf:d:o:" )

except getopt.error:
    usageError( sys.exc_info()[1], programName)

for o, a in opts:
    if o == "-q":
        infoOut("run quietly suppressing any further info output...")
        verbose=0  # really quiet
    if o == "-n":
        testmode = "on"
        infoOut(" run in test mode ...")
    if o == "-v":
        print __version__
        sys.exit()
    if o == "-h":
        usage()
        sys.exit()
    if o == "-f":
        packageListInFile = a
        if not os.path.isfile(a):
            usageError( "file " + a + " does not exist!", programName)
    if o == "-o":
        outputFormat = a
        if not a in outputFormats:
            usageError( "unknown output format: " + a + ".", programName)
        verbose = 0  # switch off extra output
    if o == "-d":
        # Skip check if url: 
        if ( a[:7] != 'http://' and not os.path.isdir(a)):
            usageError( "directory " + a + " does not exist!", programName)
        dependencyAnalysisDir = a
    
# Require at least one argument:

if not args:
    usageError("Please specify an argument: release name .  ", programName)

release = args[0];
packages = args[1:]

# Add packages from file: 
if (packageListInFile):
    f = open(packageListInFile,'r')
    for line in f.readlines():
        readPackageFromFile(line, packages)
    f.close()
infoOut( "Running " + programName)
infoOut( "Release: " + release)
infoOut( "Packages: " + string.join(packages))
infoOut( "Dependency dir: " + dependencyAnalysisDir)

# Get dependency info:
# Assume the directory structure as produced by Ignominy,
# The dependencyFormat variable specifies the file name from 
# which dependency information is to be extracted:
depFile = os.path.join(dependencyAnalysisDir, release, dependencyFormat)
f = urllib.urlopen(depFile)

# Check if first line matches :
if f.readline()[:25] != firstline:
    print 
    sys.exit("ERROR: wrong file format: " + depFile)

# 
# Skip lines outside the block:
inBlock    = 0
for line in f.readlines():
    if inBlock:
        # check if we're still in block
        if endBlock.match(line):
            inBlock = 0
        else:
            readDependencies(line, dependencies)
    else:
        if beginBlock.match(line):
            inBlock = 1
f.close()

# Check for unknown packages: 
for name in packages:
    found=0
    tmpLen = len(name)
    for line in dependencies:
        # Assume all packages belong to CMSSW:
        if line[:tmpLen+8] == name[:tmpLen] + "(CMSSW):" :
            found = 1
        else:
            continue
    if not found:        
        sys.exit ("ERROR: package unknown to CMSSW: " + name )

# First get all required CMSSW packages: 

count = 0
step = 0
while count != len(packages):
    step = step + 1
    count=len(packages)
    # Update list of packages using direct dependency info: 
    for line in dependencies:
        (p,d)=line.split(':')        
        # Filter out non-CMSSW packages and dependencies: 
        if p[-7:] == '(CMSSW)': # this is a CMSSW package!
            p = p[:-7]
        else:
            continue
        if d[-7:] == '(CMSSW)': # this is a CMSSW package!
            d = d[:-7]
        else:
            continue
        if (p in packages) and (d not in packages):
            packages.append(d)

# Now get direct external dependencies:

externals=[]
for line in dependencies:
    (p,d)=line.split(':')
    if not p[:-7] in packages:
        continue
    # Filter out CMSSW dependencies: 
    if (d[-7:] == '(CMSSW)') or (d in externals): # this is a CMSSW package!
        continue
    else:
        externals.append(d)

# Print output and finish:

if outputFormat == "packages":
    packages.sort()
    for p in packages:
        print p
    sys.exit()

if outputFormat == "tools":
    externals.sort()
    for e in externals:
        print e
    sys.exit()

if outputFormat == "dependencies":
    dependencies.sort()
    for d in dependencies:
        print d
    sys.exit()

# Default output in human readable format: 

print "## Required PACKAGES:"
packages.sort()
for p in packages:
    print p

print "## Required EXTERNALS:"
externals.sort()
for e in externals:
    print e

print "## Total number of packages:", count
print "## Total number of externals:", len(externals)
